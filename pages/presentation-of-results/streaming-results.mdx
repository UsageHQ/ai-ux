import { SampleUI } from '@components/sample-ui';
import ChatGPT from '@assets/chatgpt-chat.webp';
import Perplexity from '@assets/perplexity-chat.webp';
import Framer from '@assets/framer-menubased.webp';

# Streaming Results

<br />
<div className='w-full grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-8'>
  <SampleUI
    src={ChatGPT}
    appName='ChatGPT'
    desc="Text responses in ChatGPT are displayed in typing effect. This is the most popular way of presenting textual content in chatbots. This helps in creating a conversational feel and maintaining user engagement, also reduce the cognitive load of reading long responses."
    productUrl='https://www.chat.openai.com'
  />
   <SampleUI
      src={Perplexity}
      appName='Perplexity'
      desc="Perplexity provide textual response together rich interaction elements like buttons, images, and more. This helps in providing more context to the user and make the response more engaging. This can be useful in providing more information or options to the user."
      productUrl='https://perplexity.ai/'
   />
     <SampleUI
    src={Framer}
    appName="Framer no-code website builder"
    desc='Textual resonses in Framer are displayed right in the place users request for. This helps in providing context to the user and make the response more engaging. This is a popular pattern when building app that provide inline information.'
    productUrl='https://www.framer.com/'
  />

</div>

<br />

<div className="border border-neutral-200 dark:border-neutral-700 bg-neutral-50 dark:bg-neutral-800 p-8 rounded-lg">
    **Problem**: Users may become impatient or lose interest in AI applications that require long processing times before presenting any results, leading to a disconnected and frustrating user experience.
    
    **Example**: In an AI-driven chat application, users might disengage if they have to wait for the complete response to be processed and displayed in one go, rather than seeing it appear as it's being generated.

    **Usage**: "Streaming Results" is an effective pattern in real-time applications like chatbots, live data analysis tools, or any interactive platform where immediate engagement is crucial. This pattern allows content to be streamed and rendered incrementally, maintaining user engagement by providing immediate feedback.

</div>

## Solution

The "Streaming Results" pattern involves the incremental delivery and display of content as it is generated by the AI, simulating a more natural and engaging interaction:

- **Incremental Display**: Implementing a system where results are shown piece by piece, akin to the typing effect in messaging, which helps keep users engaged as they see the response forming.
- **Real-time Updates**: Continuously updating the user interface with new information as soon as it's available, ensuring that users receive the freshest data without delays.
- **Buffer Management**: Efficiently managing data buffers to ensure a smooth and continuous streaming experience, preventing interruptions or lag in displaying the results.
- **Adaptive Loading**: Dynamically adjusting the streaming speed based on the user's interaction speed and system capabilities, optimizing the experience for different environments and use cases.

## Rationale

Adopting the "Streaming Results" pattern offers several advantages:

- **Enhances User Engagement**: By providing results in real-time, users remain connected to the interaction, reducing drop-off rates due to waiting times.
- **Improves Perceived Speed**: Streaming results make the AI system appear faster, as users start receiving parts of the output immediately, improving their overall perception of the application's efficiency.
- **Maintains Interest**: The incremental revelation of results keeps users curious and interested in the final outcome, enhancing the interactive experience.
- **Supports User Patience**: This approach can make waiting for complex processing more bearable, as users can see progress in real-time, helping to set and manage expectations.

Incorporating "Streaming Results" into AI product design effectively addresses common challenges associated with user engagement and satisfaction, particularly in applications where timeliness and interaction fluidity are paramount.
